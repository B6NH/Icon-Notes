
# Sample Programs

# ---------------------------------------------------------

record exrecord(a,b,c,d)

# ---------------------------------------------------------

# Author: Robert J. Alexander with additions by Gregg M. Townsend
procedure options(arg, optstring, errproc)

  local f, fList, fileArg, fn, ignore, opttable, opttype, p, x, option, optname

  # Initialize.
  #
  /optstring := string(&letters)
  /errproc := stop
  option := table()
  fList := []
  opttable := table()

  # Scan the option specification string.
  #
  optstring ? {

    while optname := move(1) do {

      # Skip blank
      if optname == " " then {
        next
      }

      # Long option name
      if optname == "-" then {
        optname := tab(many(&letters)) | move(1) | break
      }

      # Set option type
      opttype := tab(any('!:+.')) | "!"

      # Save option in table
      opttable[optname] := opttype

    }

  }

  # Iterate over program invocation argument words.
  #
  while x := get(arg) do {

    if /x then {
      ignore := &null # if end of args from file, stop ignoring
    } else {

      # Scan argument (first from pair)
      x ? {

        # If '-' is not at the end and ignore is null
        if ="-" & not pos(0) & /ignore then {

          # Second '-'
          if ="-" & pos(0) then {
            ignore := 1 # ignore following args if --
          } else {

            # Scan option name
            tab(0) ? {

              until pos(0) do {

                # Find option name and type
                if opttype := \opttable[optname := ((pos(1), tab(0)) | move(1))] then {

                  # Save value in table
                  option[optname] :=
                    if any(':+.', opttype) then {

                      p := "" ~== tab(0) | get(arg) | return errproc("No parameter following -" || optname)

                      case opttype of {
                        ":": p
                        "+": integer(p) | return errproc("-" || optname || " needs numeric parameter")
                        ".": real(p) | return errproc("-" || optname || " needs numeric parameter")
                      }

                  # Argument without type
                  } else {
                    1
                  }

                # Option not found
                } else {
                  return errproc("Unrecognized option: -" || optname)
                }

              }

            }

          }

        # If the argument begins with the character "@", fetch option
        # words from lines of a text file.
        #
        } else if ="@" & not pos(0) & /ignore then {

          # Open text file
          f := open(fn := tab(0)) | return errproc("Can't open " || fn)
          fileArg := []

          # Collect arguments
          while put(fileArg, read(f))
          close(f)

          # Last argument is null
          push(arg) # push null to signal end of args from file

          # Push other arguments
          while push(arg, pull(fileArg))

        } else {

          # Different type of argument
          put(fList, x)

        }

      }

    }

  }

  # Move arguments
  while push(arg, pull(fList))

  return option

end

procedure showValues(optionsTable)
  write("S: ",optionsTable["s"])
  write("B: ",optionsTable["b"])
  write("P: ",optionsTable["p"])
  write("Inum: ",optionsTable["inum"])
  return
end

procedure checkArgs(arguments)

  if 0 = *arguments then {
    write("All arguments")
  }

  return

end

procedure showAndCheck(optionsTable,arguments)
  showValues(optionsTable)
  checkArgs(arguments)
  return
end

procedure testOptions(arguments,spString)

  local optionsTable

  optionsTable := options(arguments,spString)
  showAndCheck(optionsTable,arguments)
  line()

  return

end

# ---------------------------------------------------------

# Author: Robert J. Alexander
procedure ximage(x, indent, done)

  local i, s, ss, state, t, xtag, tp, sn, sz

  static tr

  # If this is the outer invocation, do some initialization.
  #
  if /(state := done) then {
    tr := &trace ; &trace := 0 # postpone tracing while in here
    indent := ""
    done := table()
  }

  # Determine the type and process accordingly.
  #
  indent := (if indent == "" then "\n" else "") || indent || " "
  ss := ""

  tp := type(x)

  s := if xtag := \done[x] then {
    xtag
  } else {

    case tp of {

      # Unstructured types just return their image().
      #
      "null" | "string" | "integer" | "real" | "cset" | "co–expression" |
      "file" | "procedure" | "window": image(x)

      "list": { # list

        image(x) ? {

          tab(6)

          # Identifier
          sn := tab(find("("))

          # Size
          sz := tab(0)

        }

        # Label (L8, L7, L6, ...)
        done[x] := xtag := "L" || sn

        # Figure out if there is a predominance of any object in the
        # list. If so, make it the default object.
        #
        t := table(0)

        # Count objects in list
        every t[!x] +:= 1

        # Zero occurrences of anonymous object
        s := [, 0]

        # Generate pairs
        every t := !sort(t) do {

          # Find pair with largest second element (occurrences)
          if s[2] < t[2] then {
            s := t
          }

        }

        # More than 33% elements are s[1]
        if s[2] > *x / 3 & s[2] > 2 then {

          # Element
          s := s[1]

          # Indented image of most frequent element
          t := ximage(s, indent || " ", done)

          # Braces and identifier
          if t ? (not any('\'"') & ss := tab(find(" :="))) then {
            t := "{" || t || indent || " " || ss || "}"
          }

        } else {
          s := t := &null
        }

        # Output the non–defaulted elements of the list.
        #
        ss := ""
        every i := 1 to *x do {
          if x[i] ~=== s then {
            ss ||:= indent || xtag || "[" || i || "] := " || ximage(x[i], indent, done)
          }
        }

        # Type and size
        s := tp || sz

        # Insert element
        s[-1:-1] := ", " || \t

        # Tag and elements
        xtag || " := " || s || ss

      }

      "set": { # set

        image(x) ? {
          tab(5)
          sn := tab(find("("))
        }

        # Identifier
        done[x] := xtag := "S" || sn

        # Sorted elements
        every i := !sort(x) do {

          t := ximage(i, indent || " ", done)

          if t ? (not any('\'"') & s := tab(find(" :="))) then {
            t := "{" || t || indent || " " || s || "}"
          }

          ss ||:= indent || "insert(" || xtag || ", " || t || ")"

        }

        # Concatenate
        xtag || " := " || "set()" || ss

      }

      "table": { # table

        image(x) ? {
          tab(7)
          sn := tab(find("("))
        }

        # Table label
        done[x] := xtag := "T" || sn

        # Output the table elements. This is a bit tricky, since
        # the subscripts might be structured, too.
        #
        every i := !sort(x) do {

          # Subscript image
          t := ximage(i[1], indent || " ", done)

          if t ? (not any('\'"') & s := tab(find(" :="))) then {
            t := "{" || t || indent || " " || s || "}"
          }

          # Subscripts and values
          ss ||:= indent || xtag || "[" || t || "] := " || ximage(i[2], indent, done)

        }

        # Output the table, including its default value (which might
        # also be structured.
        #
        t := ximage(x[[ ]], indent || " ", done)

        if t ? (not any('\'"') & s := tab(find(" :="))) then {
          t := "{" || t || indent || " " || s || "}"
        }

        # Table image
        xtag || " := " || "table(" || t || ")" || ss

      }

      default: { # record

        image(x) ? {
          move(7)
          t := ""
          while t ||:= tab(find("_")) || move(1)
          t[-1] := ""
          sn := tab(find("("))
        }

        done[x] := xtag := "R_" || t || "_" || sn

        # Record fields
        every i := 1 to *x do {

          name(x[i]) ? {
            (tab(find(".")), sn := tab(0))
          }

          # Add field image
          ss ||:= indent || xtag || sn || " := " || ximage(\x[i], indent, done)

        }

        # Return image
        xtag || " := " || t || "()" || ss

      }

    }

  }

  # If this is the outer invocation, clean up before returning.
  #
  if /state then {
    &trace := tr # restore &trace
  }

  return s

end

# Write ximages of x1, x1, ..., xn.
procedure xdump(x[])
  every write(&errout, ximage(!x))
  return x[-1] | &null
end

procedure testImage()

  local lst, z, st, tb, re, rc

  lst := [1,2,[3,[4,5],6,7],8,9]

  # Unstructured types
  write(ximage(5))
  write(ximage("abc"))
  write(ximage('def'))
  write(ximage(xdump))

  line()

  # Lists
  write(ximage(lst))
  write(ximage([2,3,4,5,5,5,5,5,5,4,5,5,5,5,5]))
  z := [8,9]
  write(ximage([1,2,3,4,z,z,z,z,z,z,z,5,z,z,z,z]))

  line()

  # Sets
  st := set([2,4,3,2,4,5,4])
  insert(st,[st,z])
  write(ximage(st))

  line()

  # Tables
  tb := table(0)
  tb["A"] := 2
  tb["B"] := 5
  tb[z] := 8
  write(ximage(tb))

  line()

  # Records
  rc := exrecord(5,6,7,8)
  re := exrecord(1,tb,z,rc)
  write(ximage(rc))
  write(ximage(re))

  line()

  # Xdump
  xdump(rc,re,z,tb)

  line()

  return

end

# ---------------------------------------------------------

procedure line()
  write(repl("-",50))
  return
end

procedure main()

  local spString

  # Set specification string
  spString := "s:b.p+-inum+"

  line()

  # Command line arguments
  testOptions(["-s","parstring","-b","5.2","-inum","15","-p","8"],spString)

  # Arguments from file
  testOptions(["@argfile.txt"],spString)

  # Ximage
  testImage()

end
