# ---------------------------------------------------------

link graphics

# ---------------------------------------------------------

# Graphics Programming in Icon

# ---------------------------------------------------------

# Redefine name
$define Margin 1
$ifdef Margin
  $undef Margin
  $define Margin 2
$endif

record testr(a,b,c,d)

# ---------------------------------------------------------

procedure greet(name)
  write("Hi there!")
  write("My name is ", name, ".")
  return
end

procedure shuffle(X)

  local i

  every i := *X to 2 by -1 do {
    X[?i] :=: X[i]
  }

  return X

end

procedure icon()

  local lst, r

  # Procedure call
  greet("George")

  # Argument list
  lst := [1,2,3,4]
  write ! lst

  # Show defined value
  write("Margin: ",Margin)

  # Shuffle record fields
  r := testr(1,2,3,4)
  shuffle(r)
  write("Record: ",r.a,r.b,r.c,r.d)

  return

end

# ---------------------------------------------------------

procedure rectangles()

  local width, height, x, y, w, h, colors, rect, brk

  width := 500 ; height := 300
  colors := ["red", "blue", "green", "yellow", "purple", "white", "black"]
  rect := [FillRectangle, DrawRectangle]

  write("Event processing started")

  brk := 0
  repeat {

    # Random width and height
    w := ?width
    h := ?height

    # Position
    x := ?width - w / 2
    y := ?height - h / 2

    # Set random color
    Fg(?colors)

    # Random rectangle
    (?rect)(x, y, w, h)

    # Wait for events
    WDelay(300)

    # Process events
    while *Pending() > 0 do {

      case Event() of {

        # Hold down left mouse button to pause drawing rectangles
        &lpress: {
          until Event() === &lrelease
          write("Left mouse button released")
        }

        "q": {
          brk := 1
        }

      }

    }

    if 1 = brk then break

  }

  write("Event processing complete")

  return

end

procedure graphics()

  local normal

  # Open 400x300 (width x height) pixel window
  # Background color is light gray
  WOpen("label=Graphics","size=400,300","bg=light gray")

  # Set colors and line width
  # Enable window resizing
  WAttrib("fg=white","bg=black","linewidth=4","resize=on")
  Fg("red") ; Bg("black")

  # Show foreground color
  write("Foreground: ",WAttrib("fg"))

  # Display text inside window
  WWrite("Hello World!")

  # Draw red rectangle
  DrawRectangle(20,30,200,100)

  # Store attributes in list
  normal := ["bg=white", "fg=orange"]

  # Set attributes using list
  WAttrib ! normal

  # Blue rectangle
  FillRectangle(250,40,70,70)

  # Fill rectangle with background color
  Bg("black")
  EraseArea(250,40,40,40)

  # Two rectangles
  Fg("green")
  DrawRectangle(80,150,60,60,
                100,160,70,70)

  # Synchronize
  # WSync()

  # Wait 5 seconds
  WDelay(5000)

  # Rectangles
  rectangles()

  # Wait for 'q'
  write("Press 'q' to quit")
  WDone()

  return

end

# ---------------------------------------------------------

procedure sierpinski()

  local width, height, x1, y1, x2, y2, x3, y3, x, y

  width := 400 ; height := 400
  x1 := 0 ; y1 := height
  x2 := width / 2 ; y2 := 0
  x3 := width ; y3 := height
  x := width / 2 ; y := height / 2

  # Loop until 'q' is pressed
  until WQuit() do {

    case ?3 of {

      1 : {
        write("Old ",x," - ",y)
        x := (x + x1) / 2
        y := (y + y1) / 2
        write("New ",x," - ",y)
      }

      2 : {
        x := (x + x2) / 2
        y := (y + y2) / 2
      }

      3 : {
        x := (x + x3) / 2
        y := (y + y3) / 2
      }

    }

    DrawPoint(x,y)

  }

  return

end

procedure rPolygon(cx,cy,radius,vertices,skips)

  local theta, incr, xprev, yprev, x, y

  # By default don't skip points
  /skips := 1

  # Current position
  theta := 0

  # Angle between points
  incr := skips * 2 * &pi / vertices

  # First point
  xprev := cx + radius * cos(theta)
  yprev := cy + radius * sin(theta)

  every 1 to vertices do {

    # Update angle
    theta +:= incr

    # Next point
    x := cx + radius * cos(theta)
    y := cy + radius * sin(theta)

    # Line between points
    DrawLine(xprev,yprev,x,y)

    # Save last point
    xprev := x ; yprev := y

  }

  return

end

procedure spokes(cx,cy,radius,n)

  local theta, incr, points

  # Calculate angle
  theta := 0
  incr := 2 * &pi / n

  # Collect pairs of points
  points := []
  every 1 to n do {
    put(points,cx,cy)
    put(points,cx + radius * cos(theta),cy + radius * sin(theta))
    theta +:= incr
  }

  # Draw lines
  DrawSegment ! points

  return

end

procedure checkerboard()

  local size, edge, offset, squares, i, j, sqSize, offEdge, sqEdge

  size := 11 ; edge := 4 ; offset := 170 ; squares := 8

  every i := 0 to squares - 1 do {

    every j := 0 to squares - 1 do {

      # Squares in row
      if (i + j) % 2 = 1 then {
        FillRectangle(offset + i * size, offset + j * size, size, size)
      }

    }

  }

  # Board size
  sqSize := squares * size

  # Top left
  offEdge := offset - edge

  # Size with border
  sqEdge := sqSize + 2 * edge

  # Inner border
  DrawRectangle(offset,offset,sqSize,sqSize)

  # Outer border
  DrawRectangle(offEdge,offEdge,sqEdge,sqEdge)

  return

end

procedure triangles()

  local v, leftX, midX, topY, botY, rightX, offset

  # Positions of left and top vertices
  v := [200,220,240,260]
  offset := 220

  # Draw triangles
  every leftX := !v do {

    midX := leftX + 15

    # Column of triangles
    every topY := !v do {

      botY := topY + 30
      rightX := leftX + 30

      # Connect points
      DrawPolygon(midX + offset, topY,
                  leftX + offset, botY,
                  rightX + offset, botY)

    }

  }

  return

end

procedure wheel(cx,cy,radius,n,hubradius,tirewidth,rimwidth)

  local i, tireradius

  # Draw spokes and inner circle
  spokes(cx,cy,radius,n)
  DrawCircle(cx,cy,radius)

  # Middle circle
  FillCircle(cx,cy,hubradius)

  # Tire and rim
  tireradius := radius + rimwidth
  every i := 0 to tirewidth - 1 do {
    DrawCircle(cx,cy,tireradius + i)
  }

  return

end

procedure eggs()

  local x, y, p4

  p4 := &pi / 4

  every y := 180 | 220 do {

    every x := 675 to 775 by 25 do {

      DrawCircle(

        # Bottom
        x, y, 10, 0.0, &pi,

        # Left part
        x + 10, y, 20, &pi, p4,

        # Top
        x, y - 10, 6, 5 * p4, &pi / 2,

        # Right
        x - 10, y, 20, 7 * p4, p4)

    }

  }

  return

end

procedure aStar(cx,cy,radius,vertices,ecc)

  local acr, x, y, r, kappa, theta, extent

  # Eccentricity
  if ecc < 0.1 then {
    ecc := 0.1
  }

  # Half of angle between points
  kappa := &pi / vertices

  # Radius to small circle center
  acr := radius / (ecc * cos(kappa))

  # Vertical
  x := acr - radius * cos(kappa)

  # Horizontal
  y := radius * sin(kappa)

  # Calculate radius of small circle
  r := sqrt(y^2 + x^2) + 0.5

  # Angle of drawn part
  extent := 2 * atan(y,x)

  # Initial angle
  theta := &pi / 2

  # Draw part of circles around main circle
  every 1 to vertices do {

    # Arc center
    x := cx + acr * cos(theta)
    y := cy + acr * sin(theta)

    # Draw arc
    DrawCircle(x,y,r,theta + &pi - extent / 2,extent)

    # New angle
    theta +:= 2 * kappa

  }

  return

end

procedure arcRect()

  # Rectangle
  DrawRectangle(535,260,100,50)

  # Top left to right down
  DrawLine(535,260,635,310)

  # Down left to right up
  DrawLine(535,310,635,260)

  # Arc inside
  DrawArc(535,260,100,50,&pi/4,&pi)

  return

end

procedure bali()

  local y, w

  # Clear screen
  EraseArea()

  # Initial position and line width
  y := 165 ; w := 1

  every 1 to 9 do {

    # Set line width
    WAttrib("linewidth=" || w)

    # Draw wave
    DrawLine(50,y,600,y)

    # Lower lines are thicker
    y +:= 2 * w + 1
    w +:= w / 3 + 1

  }

  WAttrib("linewidth=4")

  # Sun
  DrawCircle(150,140,50,&pi/6,-4*&pi/3)

  return

end

procedure highway()

  EraseArea()

  WAttrib("linewidth=3")

  # Main road
  Fg("light gray")
  FillRectangle(0,50,500,160)

  # Black lines on main road
  Fg("black")
  DrawLine(0,126,500,126)
  DrawLine(0,134,500,134)

  # Striped lines on main road
  WAttrib("linestyle=striped")
  DrawLine(0,88,500,88)
  DrawLine(0,172,500,172)

  # Side road that covers part of lines on main road
  Fg("light gray")
  FillRectangle(120,50,80,250)

  # Lines on side road
  Fg("black")
  WAttrib("linestyle=dashed")
  DrawLine(160,210,160,300)

  return

end

procedure drawing()

  local x, rs

  # Open window
  WOpen("size=920,400")

  # Draw points
  DrawPoint(10,10,20,10,30,10,40,10)

  # Sierpinski triangle
  # Fg("orange")
  # sierpinski()

  # Purple line
  Fg("purple")
  DrawLine(60,10,120,40)

  # Regular red polygon
  Fg("red")
  rPolygon(200,80,60,7)

  # Star
  Fg("blue")
  rPolygon(330,80,60,7,4)

  # Draw connected lines to form triangle
  Fg("green")
  DrawLine(400,30,450,130,500,80,400,30)

  # Lines between pairs of points
  DrawSegment(10,20,30,50,50,40,30,80)

  # Spokes
  spokes(80,200,60,20)

  # Rectangle design
  Fg("blue")
  every x := 60 to 88 by 4 do {
    rs := 180 - 2 * x
    DrawRectangle(x, x, rs, rs)
  }

  # Normal circle
  Fg("purple")
  DrawCircle(560,70,45)

  # Checkerboard
  checkerboard()

  # Filled triangle
  # Polygon is closed automatically
  Fg("red") ; FillPolygon(290,180,320,260,400,200)

  # Triangles
  Fg("blue") ; triangles()

  # Even-odd rule
  Fg("orange") ; FillPolygon(540,200,640,200,590,250,590,150,640,250)

  # Part of circle
  FillCircle(670,70,45,&pi,&pi/2)

  # Wheel
  Fg("blue") ; wheel(770,80,50,30,8,5,11)

  # Eggs
  eggs()

  # Arched star
  Fg("purple") ; aStar(850,200,50,8,1.5)

  # Arc inside rectangle
  arcRect()

  # Smooth curve
  Fg("red") ; DrawCurve(680,260,780,260,680,310,780,310)

  # Bali
  # bali()

  # Highway
  # highway()

  WDone()

  # Reversible drawing
  WAttrib("drawop=reverse")
  every x := 1 to 100 do {

    # Draw rectangle first time
    FillRectangle(x, 100, 10, 20)

    WDelay(1)

    # Drawing figure twice erases it
    FillRectangle(x, 100, 10, 20)

  }

  FillRectangle(x, 100, 10, 20)

  # Set Offset
  # WAttrib("dx=60", "dy=60")

  # Restrict drawing
  # Clip(0,0,20,20)

  # Press 'q'
  WDone()

  return

end

# ---------------------------------------------------------

procedure turtle()

  return

end

# ---------------------------------------------------------

procedure main()

  # icon()
  # graphics()
  drawing()

end

# ---------------------------------------------------------
