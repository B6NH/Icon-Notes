
# Icon Programming for Humanists

global letters, limit, chartable,
       A, a, B, b, C, c, D, d, E, e, F, f, impermissible

# Save word lengths in list
procedure word_lengths(line)

  local length

  letters := list(10,0)

  line ? while length := *tab(many(&letters)) do {
    tab(many(' .,;:!'))
    letters[length] +:= 1
  }

  return

end


# Display values from global list letters
procedure printout()

  local n

  every n := 1 to 10 do write("There are ",letters[n]," ",n,"-letter words.")

  return

end

procedure dispChars()

  local n

  # Display characters
  every n := 0 to 255 do {
    writes(right(n,3) ,"=" ,char(n)," ")
    if n % 13 = 0 then write()
  }

  return

end

# Show histogram of letters
procedure histogram()

  local n, p

  every n := 30 to 1 by -1 do {
    writes(repl(" ",10))
    every p := 1 to 10 do writes(if letters[p] >= n then "X" else " ")
    write()
  }

  return

end

procedure getword(filename)

  local chars, punct, filvar, line, word

  # Initialize sets
  chars := (&letters ++ &digits ++ '\'-')
  punct := ' .,?";:!'

  # Open file
  filvar := open(filename)

  # Read lines
  while line := read(filvar) do {
    line ? {

      # Skip blanks
      tab(many(' '))

      # Read word
      while word := tab(many(chars)) do {

        # Skip punctuation
        tab(many(punct))

        # Return one word
        suspend word

      }

    }

  }

  # Close file
  close(filvar)

  # Procedure must fail
  # ...

end

# Number of words in file
procedure countfile(filename)

  local total

  total := 0

  every getword(filename) do total +:= 1

  return total

end

procedure modesMeansMedians(filename)

  local filelength, section, counter, letters, word

  # File length
  filelength := countfile(filename)

  # Section size
  limit := (filelength / 3)

  # Number of sections
  section := 0

  # Word counter
  counter := 0

  # Frequencies
  letters := list(20,0)

  # Read words
  every word := getword(filename) do {

    # Increment number of words of this size
    letters[*word] +:= 1
    counter +:= 1

    # Next section
    if counter = limit then {

      # Display section
      printSection(section +:= 1, letters)
      printMean(section,letters)
      printMedian(section,letters)

      # Reset variables
      letters := list(20,0)
      counter := 0

    }

  }

  return

end

procedure printSection(p, L)

  local greatest, n, mode

  greatest := 0

  write("Section no. ", p, ".")
  write("Length Number Such")

  # Find most frequent value
  every n := 20 to 1 by -1 do {

    # Show values
    write(right(n, 2),right(L[n], 12))

    # Check if it is greater than greatest
    if L[n] > greatest then {
      greatest := L[n]
      mode := n
    }

  }

  write(" ", "Mode = ", mode)

  return

end

procedure printMean(p, L)

  local letter_total, n

  letter_total := 0

  # Sum word lengths
  every n := 20 to 1 by -1 do letter_total +:= (n * L[n])

  # Display arithmetic mean
  write(" ", "Mean = ", real(letter_total) / limit)

  return

end

procedure printMedian(p, L)

  local lcf, n, l2, vcm, valuesToMedian,
        fractionInMedian, medianMHalf, median

  # Initialize list of cumulative frequencies
  lcf := list(20,0)

  # First elements are the same
  lcf[1] := L[1]

  # Calculate other elements
  every n := 2 to 20 do lcf[n] := (lcf[n - 1] + L[n])

  # Find index where cumulative frequency is larger than or equal half of all values
  n := 0 ; l2 := limit / 2.0
  while lcf[n +:= 1] < l2
  vcm := n

  # Number of values to median index
  valuesToMedian := l2 - lcf[vcm - 1]

  # Fraction of same values to median
  fractionInMedian := valuesToMedian / L[vcm]

  # Subtract 0.5 from median value
  medianMHalf := vcm - 0.5

  # Calculate and display median
  median := medianMHalf + fractionInMedian
  write(" ","Median = ", median)

  return

end

procedure startHTML(title,outfilvar)

  write(outfilvar,"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0Transitional//EN\">")
  write(outfilvar,"<html>")
  write(outfilvar,"<head>")
  write(outfilvar,"<title>",title,"</title>")
  write(outfilvar,"<body>")
  write(outfilvar,"<p>")

  return

end

procedure endHTML(filename,outfilvar)

  # End html
  write(outfilvar,"</p>")
  write(outfilvar,"</body>")
  write(outfilvar,"</html>")

  # Confirmation
  write("File ",filename,".html has been created.")

  return

end

# Initialize Russian chartable
procedure initR()

  local charlist, range

  # Character keys
  charlist := ["A","B","V","G","D","E","|Z","Z","I","J","K","L","M","N","O",
               "P","R","S","T","U","F","X","C","|C","W","|W","|~","Y","|`","|E","|U","|A",
               "a","b","v","g","d","e","|z","z","i","j","k","l","m","n","o",
               "p","r","s","t","u","f","x","c","|c","w","|w","~","y","`","|e","|u","|a"]

  # Character range
  range := [1040,1103]

  # Special Russian characters
  chartable["{"] := "&#171;"
  chartable["}"] := "&#187;"
  chartable["|O"] := "&#1025;"
  chartable["|o"] := "&#1105;"
  chartable["["] := "<br />"
  chartable["]"] := "</p><p>"

  initializeAny(charlist,range)

  return

end

# Initialize Tamil chartable
procedure initT()

  local charlist, range

  # Keys
  charlist := ["V","","|a","|A","|i","|I","|u","|U","","","","|e","|E","|~","",
               "|o","|O","|`","k","","","","g","c","","j","","|n","T","","","",
               "|N","t","","","","N","n","p","","","","m","y","r","R","l","L","|l",
               "v","|s","","s","h","","","","","A","i","I","u","U","","","","e",
               "E","~","","o","O","`","}"]

  # Loop range
  range := [2947,3021]

  # Other characters
  chartable["a"] := ""
  chartable["|R"] := "&#3065;"
  chartable["|P"] := "#163;"
  chartable["["] := "<br />"
  chartable["]"] := "</p><p>"

  initializeAny(charlist,range)

  return

end

# Initialize Hebrew chartable
procedure initH()

  local charlist, range

  # Character order
  charlist := ["a","b","g","d","h","v","z","j","T","y","X","x","l",
               "M","m","N","n","S","o","F","f","C","c","q","r","s","t"]

  # Codes
  range := [1488,1514]

  # Dot in the middle
  chartable["`"] := "&#x05BC;"

  initializeAny(charlist,range)

  return

end

procedure initializeRussian()
  initializeChartable(initR)
  return
end

procedure initializeTamil()
  initializeChartable(initT)
  return
end

procedure initializeHebrew()
  initializeChartable(initH)
  return
end

procedure initializeChartable(init)

  # Create new table with default value
  chartable := table("??")

  # Call init procedure
  init()

end

procedure initializeAny(charlist,range)

  local n, m

  # List index
  m := 0

  # Fill table
  every n := range[1] to range[2] do
    chartable[charlist[m +:= 1]] := "&#" || n || ";"

  return

end

# Convert text using global chartable
procedure process()

  local filename,title,infilvar,outfilvar,line,newline,char

  # Read file name and title
  write("Prepared files: Russian - \"unir.txt\", Tamil - \"unit.txt\", Hebrew - \"unih.txt\"")
  writes("Enter the name of previously prepared file (default \"uni.txt\"): ")
  filename := read() ; if "" == filename then filename := "uni.txt"

  writes("What is the title of the text? (default \"Unicode\"): ")
  title := read() ; if "" == title then title := "Unicode"

  # Open input file
  (infilvar := open(filename)) | stop(filename," not found.")

  # Open output file
  outfilvar := open(filename || ".html","w")

  # Beginning of html
  startHTML(title,outfilvar)

  # Read lines from file
  while line := read(infilvar) do {

    # Initialize new string
    newline := ""

    line ? {

      # Add characters to string
      while char := move(1) do {

        # Punctuation
        # Variable is lexically less than "A"
        newline ||:= if char << "A" then {
          char
        } else if char == "|" then {
          chartable["|" || move(1)]
        } else {
          chartable[char]
        }

      }

    }

    # Save string in file
    write(outfilvar,newline)

  }

  # End html
  endHTML(filename,outfilvar)

  return

end

procedure initHex()

 # Define hexidecimal letters
 A := a := 10
 B := b := 11
 C := c := 12
 D := d := 13
 E := e := 14
 F := f := 15

 # Other symbols
 impermissible := (&ascii -- &digits -- 'aAbBcCdDeEfF')

 return

end

procedure processHex()

  local hexno, length, result, n

  write("This program converts hex numbers to decimal.")
  writes("Enter hex number to be converted. Period (.) to finish: ")

  # Read hex number
  while (hexno := read()) ~== "." do {

    # Test input
    hexno ? if upto(impermissible) then stop(hexno," is an invalid entry.\nBye.")

    # Initialize result and string length
    length := *hexno
    result := 0

    # Add values
    every n := 1 to length do {

      # Convert digits
      result +:= convert(hexno[n],length - n)

    }

    # Display decimal result and ask again
    write("Hex number ",hexno," = ",result," decimal.")
    writes("Enter hex number to be converted. Period (.) to finish: ")

  }

  write("Bye.")

  return

end

procedure convert(digit,index)

  local outcome

  # Return hexidecimal digit value
  outcome := (integer(digit) | variable(digit)) * (16 ^ index)

  return outcome

end

procedure main()

  # Word lengths
  writes("Lengths: ")
  "One went and came." ? while writes(*tab(upto('. '))," ") do tab(many('. '))
  write()

  # Word distribution
  write("Distribution: ")
  word_lengths("It now remains to write a procedure to write out the table")
  printout()

  # Read key
  # write("Hit any key to continue")
  # getch()

  # Histogram
  histogram()

  # Display characters
  write("Characters: ") ; dispChars() ; write()

  # File modes
  modesMeansMedians("file.txt")

  # Russian
  # initializeRussian()

  # Tamil
  # initializeTamil()

  # Hebrew
  # initializeHebrew()

  # Process Russian/Tamil/Hebrew
  # process()

  # Convert hexidecimal numbers
  # initHex()
  # processHex()

end


